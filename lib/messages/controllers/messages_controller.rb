# messages
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Messages
  # MessagesController
  class MessagesController < BaseController
    def initialize(config, http_call_back: nil)
      super(config, http_call_back: http_call_back)
    end

    # Retrieve the current status of a message using the message ID returned in
    # the send messages end point.
    # A successful request to the get message status endpoint will return a
    # response body as follows:
    # ```json
    # {
    #     "format": "SMS",
    #     "content": "My first message!",
    #     "metadata": {
    #         "key1": "value1",
    #         "key2": "value2"
    #     },
    #     "message_id": "877c19ef-fa2e-4cec-827a-e1df9b5509f7",
    #     "callback_url": "https://my.callback.url.com",
    #     "delivery_report": true,
    #     "destination_number": "+61401760575",
    #     "scheduled": "2016-11-03T11:49:02.807Z",
    #     "source_number": "+61491570157",
    #     "source_number_type": "INTERNATIONAL"
    #     "message_expiry_timestamp": "2016-11-03T11:49:02.807Z",
    #     "status": "enroute"
    # }
    # ```
    # The status property of the response indicates the current status of the
    # message. See the Delivery
    # Reports section of this documentation for more information on message
    # statues.
    # *Note: If an invalid or non existent message ID parameter is specified in
    # the request, then
    # a HTTP 404 Not Found response will be returned*
    # @param [String] message_id Required parameter: Example:
    # @return [Mixed] response from the API call
    def get_message_status(message_id)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/messages/{messageId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'messageId' => { 'value' => message_id, 'encode' => true }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.get(
        _query_url,
        headers: _headers
      )
      BasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 404
        raise APIException.new(
          '',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body) unless
        _response.raw_body.nil? ||
        _response.raw_body.to_s.strip.empty?
      decoded
    end

    # Cancel a scheduled message that has not yet been delivered.
    # A scheduled message can be cancelled by updating the status of a message
    # from ```scheduled```
    # to ```cancelled```. This is done by submitting a PUT request to the
    # messages endpoint using
    # the message ID as a parameter (the same endpoint used above to retrieve
    # the status of a message).
    # The body of the request simply needs to contain a ```status``` property
    # with the value set
    # to ```cancelled```.
    # ```json
    # {
    #     "status": "cancelled"
    # }
    # ```
    # *Note: Only messages with a status of scheduled can be cancelled. If an
    # invalid or non existent
    # message ID parameter is specified in the request, then a HTTP 404 Not
    # Found response will be
    # returned*
    # @param [String] message_id Required parameter: Example:
    # @param [String] content_type Required parameter: Example:
    # @param [CancelScheduledMessageRequest] body Required parameter: Example:
    # @return [Mixed] response from the API call
    def update_cancel_scheduled_message(message_id,
                                        content_type,
                                        body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/messages/{messageId}'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'messageId' => { 'value' => message_id, 'encode' => true }
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'Content-Type' => content_type
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.put(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      BasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise APIException.new(
          '',
          _response
        )
      when 404
        raise APIException.new(
          '',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body) unless
        _response.raw_body.nil? ||
        _response.raw_body.to_s.strip.empty?
      decoded
    end

    # Submit one or more (up to 100 per request) SMS or text to voice messages
    # for delivery.
    # @param [SendMessagesRequest] body Required parameter: Example:
    # @return [Mixed] response from the API call
    def create_send_messages(body)
      # Prepare query url.
      _query_builder = config.get_base_uri
      _query_builder << '/v1/messages'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => APIHelper.get_content_type(body)
      }

      # Prepare and execute HttpRequest.
      _request = config.http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      BasicAuth.apply(config, _request)
      _response = execute_request(_request)

      # Validate response against endpoint and global error codes.
      case _response.status_code
      when 400
        raise APIException.new(
          'Error',
          _response
        )
      end
      validate_response(_response)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_response.raw_body) unless
        _response.raw_body.nil? ||
        _response.raw_body.to_s.strip.empty?
      decoded
    end
  end
end
